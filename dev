Perfect Pull Request (PR) Instruction Set for Autonomous AI Software Engineers (e.g., Devin) - V2.0
This document provides a comprehensive, non-negotiable set of instructions to be appended to any programming task given to an autonomous AI software engineer. The goal is to ensure the resulting Pull Request (PR) is of the highest quality, adheres to advanced best practices for a Node.js environment, and is immediately mergeable upon human review.



CRITICAL INSTRUCTIONS: PERFECT PULL REQUEST CHECKLIST
You MUST adhere to the following requirements for the completion of this task and the resulting Pull Request:

I. Code Quality, Maintainability, and Principles
1	Single Responsibility Principle (SRP): The changes introduced in this PR must address a single, focused feature, bug fix, or refactoring task. Do not mix unrelated concerns.
2	Clarity Over Cleverness: Prioritize code clarity, readability, and maintainability over unnecessary brevity or "clever" one-liners that sacrifice understanding. The code must be easily understood by a human reviewer.
3	Modularity and Structure: Implement all changes using clean, modular code. Ensure clear separation of concerns (e.g., business logic, data access, presentation).
4	"Tell, Don't Ask" Principle: Adhere strictly to the "Tell, Don't Ask" principle in object-oriented design. Objects should be told what to do, rather than being queried for their state to make external decisions.
5	Configuration Management: Do not hardcode any environment-specific values, secrets, or API keys. Use a secure, environment-aware configuration mechanism (e.g., environment variables, a dedicated configuration library).
6	Error Handling: Implement robust and explicit error handling. All asynchronous operations must be wrapped in appropriate try...catch blocks or use promise rejection handling. Errors must be logged with sufficient context and severity levels.

II. Testing and Validation
7	Test Coverage: Create all necessary unit, integration, and end-to-end tests to fully cover the new or modified code paths. Test coverage must not decrease.
8	Update Affected Tests: Update any existing tests that are affected by the changes to ensure they remain valid and pass.
9	Pass All Checks: Ensure that all automated checks pass:
◦	All tests must pass without any errors or warnings.
◦	The npm run build or equivalent build task must complete successfully without errors or warnings.
◦	All linting and static analysis checks (e.g., ESLint, Prettier) must pass.
10	Test Focus (Behavior over Implementation): Tests must focus on the public behavior and contract of the functions/modules, not on internal implementation details.
11	Single Assert per Test: Where possible, each unit test should contain a single, clear assertion to validate one specific behavior.
12	Mocking Strategy:
◦	Reduce the amount of mocked information to the absolute minimum required for the test to run.
◦	When testing a function's response, do not test any internal operations it performs (e.g., side effects).
◦	When testing internal operations (e.g., side effects, database writes), do not test the function's response. Separate these concerns into different tests.

III. Documentation and Dependencies
13	Documentation Update: Update all relevant documentation, including the project's README.md, API documentation (e.g., JSDoc comments), and any necessary architectural diagrams.
14	Code Comments: Add clear, concise comments to any complex or non-obvious sections of the code to explain the why behind the implementation, especially for AI-generated logic.
15	Dependency Management:
◦	Ensure no unused dependencies are introduced or remain in package.json.
◦	If new dependencies are added, they must be necessary and from reputable sources.
◦	The package-lock.json file must be updated and committed.

IV. Security and Performance
16	Security Check: Scan all new or updated dependencies for known vulnerabilities using a tool like npm audit or equivalent, and ensure all critical vulnerabilities are resolved before opening the PR.
17	Input Validation: Implement strict input validation and sanitization for all external inputs (e.g., API request bodies, query parameters) to prevent common vulnerabilities like XSS or SQL injection.
18	Performance: Ensure the changes do not introduce significant performance regressions. Avoid common pitfalls like N+1 database queries, inefficient loops, or excessive memory consumption.

V. Git and Pull Request Hygiene
19	Commit Squashing: Before creating the PR, squash all related commits into a single, atomic commit. The PR must contain only one commit. Use git rebase -i to achieve this.
20	Commit Message: The single commit message must be clear, concise, and follow the Conventional Commits specification (e.g., feat: add user authentication endpoint or fix: resolve race condition in cache).
21	PR Title and Description:
◦	The PR title must be descriptive and reflect the single commit message.
◦	The PR description must clearly state What was changed, Why it was changed, and How it was tested. Include a link to the relevant issue tracker ticket.
22	Final Step: Once all code is written, tested, and committed according to these rules, complete and push the changes to the remote branch, and open the Pull Request.

VI. Autonomy and Interaction
23	Full Autonomy: You are expected to complete the entire task autonomously, from initial code writing to final PR preparation.
24	Minimize Interaction: Do everything within your power to complete the task without asking for my interaction or help. Only ask for clarification if the original prompt is fundamentally ambiguous or if a critical, unresolvable blocker is encountered.
25	Self-Correction: If any automated check fails (e.g., tests, linting, build), you must autonomously diagnose and fix the issue before attempting to open the PR again.
