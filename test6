You are an expert in Tekton Pipelines, event-driven architecture, MongoDB performance optimization, and large-scale CI/CD telemetry systems.


---

Context (Expanded)

I am building a service that listens to Tekton events and stores only the essential information needed for a UI dashboard.
The dashboard will display pipeline and task progress, statuses, timestamps, and possibly additional metadata.

Important:
I will provide:

An image of the UI (a screenshot of the exact dashboard)

A schema describing what fields the UI needs


You should not assume what fields the UI requires.
Your job is to help me plan the ingestion system before I provide the UI data, so the design should be generic, flexible, and focused on minimizing unnecessary work.

I will store Tekton data in two MongoDB collections:

pipelineRuns

taskRuns


The system must be high-performance, with:

The minimum possible number of database writes

The minimum possible event parsing

Avoiding redundant updates

Ensuring the UI remains accurate and live


This means we need to decide:

Which Tekton events are useful

Which Tekton events can be ignored

What fields can and should be extracted from each event type

How to design a schema that supports the UI once I share it


The goal is to create a data ingestion strategy that is both correct and as cheap as possible computationally.


---

Your Task

Design a complete ingestion, filtering, and storage strategy, including:

1. Which Tekton events must be processed and
which events can be safely ignored to minimize load.


2. Where in the Tekton event structure the relevant fields can be found, including:

metadata

status fields

conditions

timestamps

results

annotations and labels



3. A minimal extraction model
(later I will refine it based on the UI needs and provide a screenshot + schema).


4. MongoDB schema suggestions
— not final, but a recommended starting point — optimized for:

minimal writes

minimal per-event updates

fast read performance

efficient linking between PipelineRuns and TaskRuns



5. A DB-write minimization strategy, including:

which events should trigger updates

which fields require updates and when

how to avoid frequent writes during long-running tasks

idempotency design

“write-once, update-only-on-state-change” logic



6. How to correlate TaskRuns to their parent PipelineRun using fields in Tekton events.


7. How to handle missing or partial Tekton events while still providing consistent UI data.


8. Examples of the expected stored documents for both PipelineRun and TaskRun using the minimal required fields (placeholders are fine until I provide the UI schema).


9. A recommended processing flow, including:

event received → filter → extract minimal fields → detect if update is needed → write or skip


10. Any pitfalls, edge cases, or Tekton behavior patterns that affect how runs start, update, or complete.




---

Output Requirements

Please structure the output with:

Clear sections

Bullet lists

Concise technical explanations

Code-like examples where relevant

Strong focus on performance, minimal DB writes, and minimal event consumption

